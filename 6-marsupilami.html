<section class="plan center">
	<h5>Implementation & Test case</h5>
	<ul>
		<li>Introduction to the concept</li>
		<li>Design process : overview</li>
		<hr>
		<li>Beam model : variational approach</li>
		<li>Beam model : equilibrium approach</li>
		<li >New discrete beam element</li>
		<hr>
		<li class="highlight">Implementation & Test case</li>
	</ul>
	<aside class="notes">
		Dans le temps qui me reste, je vais vous présenter l'implémentation que j'ai fait de ce modèle dans un code de calcul que j'ai baptisé Marsupilami.
		<hr>
		Ce code m'a permi de valider le modèle sur un certain nombre de cas tests que je vous présenterai également.
		<hr>
		Pour finir, je dresserai un état des lieux sur le développement de ce code et proposerait quelques pistes pour le rendre utilisable par un public plus large.
	</aside>
</section>

<!-- 
=============================================================================================== 
	Marsupilami
=============================================================================================== 
-->
<section class="plan center">
	<strong>Marsupilami</strong>
	<aside class="notes">
	</aside>
</section>

<section class="">
	<h5 class="">environment</h5>
	<ul>
		<li>Rhino : (proprietary) versatile 3D modeler, powered by NURBS</li>
		<li>Grasshopper : multipurpose graphical algorithm editor for Rhino</li>
		<li>Well established tools in the field of architetural and structural design of complex envelopes</li>
	</ul>
	<hr>
	<img class="stretch" data-src="./img/case/rhgh.png"/>
	</div>
	<aside class="notes">
		Marsupilami a été développé dans l'idée d'être employé dans l'ecosystème Rhino & Grasshopper.
		<hr>
		Rhino est un modeleur 3D bien implanté auprès des architectes et des ingénieurs qui travaillent sur des formes complexes (Fenêtre de gauche)
		<hr>
		Il est fourni avec le plugin Grasshopper qui permet de générer des algorithmes de manière graphique (fenêtre de droite).
		<hr>
		En combinant des composants l'utilisateur peu créer des logiques très complexes. De nombreux composants sont déjà mis à disposition par des tierses parties et l'on peut développer son propre jeu de composants en language C#.
		<hr>
		A la manière d'excel, Grasshopper devient un outil à faire des outils et rend facile la diffusion et la combinaison d'algorithmes quels qu'ils soient.
		<hr>
		En outre, la logique interne de rhino est exposée au développeur via l'API RhinoCommon ce qui lui offre tous les outils nécessaires pour manipuler et afficher de la géométrie et s'éviter le développement d'une interface graphique indépendante.
		<hr>
	</aside>
</section>

<section class="">
		<h5 class="">Coding Language</h5>
		<ul>
			<li>C# is an ECMA standard (top five language)</li>
			<li>Garbage collection</li>
			<li>.Net Framework > .Net Core / Mono (open source)</li>
			<li>Portability : Windows, Linux, macOS, and mobile devices</li>
			<li>Few existing scientific librairies (C++, Python, Julia)</li>
		</ul>
		</div>
		<aside class="notes">
			Marsupilami est donc développé en C# pour pouvoir s'intégrer san heurt à l'environnement Rhino & Grasshopper. Ce choix n'est pas neutre mais possède de sérieux avantages.
			<ul>
				<li>C# est un language mature et robuste, très largement utilisé.</li>
				<li>Bien qu'initialement développé par Microsoft sur un mode propriétaire, son développement s'effectue sur le mode de l'opensource depuis 3 ans.</li>
				<li>Le code est en outre facilement portable sur d'autre plateformes ce qui est un avantage indéniable</li>
				<li>En revanche, on peu déplorer le manque de bibliothèques scientifiques existantes par rapport à d'autres languages mieux implantés dans la communauté scientifique</li>
			</ul>
		</aside>
	</section>

<section class="">
	<h5 class="">Architecture : API</h5>
	<ul>
		<li>Application Programming Interface (portable)</li>
		<li>Dependence-Free</li>
		<hr>
		<li>Marsupilami.MathLib : Point, Vector, Frame, Centerline</li>
		<li>Marsupilami.CoreLib : Element, Material, Section, Solver</li>
		<li>Marsupilami.Gh : Grasshopper interface</li>
	</ul>
	<hr>
	<img class="stretch" data-src="./img/case/github.png"/>
	</div>
	<aside class="notes">
		Bien que destinée à être utilisée premièrement dans Rhino Grasshopper, Marsupilami est pensé comme une API sans dépendance avec des programmes tierces, autres que ceux nécesssaires à la compilation et l'exécution du language.
		<hr>
		Cette API portable est scindée en deux bibliothèques : une de math et une de mécanique
		<hr>
		Marsupilami est exposé à Rhino Grasshopper via l'interface Marsupilami.Gh qui ajoute une barre d'outil dans la fenêtre de Grasshopper.
		<hr>
		A l'avenir, grâce à cette architecture, d'autres interfaces pourraient voir le jour sans changer le fonctionnement de l'API, par exemple pour excel, revit, etc.
	</aside>
</section>

<section class="">
	<h5 class="">Architecture : CODE</h5>
	<ul>
		<li>Object-Oriented Programming > Modularity & Abstraction</li>
		<li>Sequential vs. Event-driven Programming</li>
		<li>Parallel Programing</li>
	</ul>
	<hr>
	<img class="stretch" data-src="./img/case/github.png"/>
	</div>
	<aside class="notes">
		Le code de Marsupilami tire parti des concepts de programmation orientée objet pour gagner en modularité et offrir un bon niveau d'abstraction. Par exemple, celà nous permet de mixer des éléments à 3, 4 et 6 degrés de libertés dans un même modèle.
		<hr>
		Par ailleurs, nous avons aussi fait usage de la programmation par évènement qui permet des usages nouveaux difficiles voir impossibles à implémenter avec un mode de programmation séquentiel.
		<hr>
		Par exemple, cela nous a permis d'implémenter des fonctionnalités de raffinement automatique des éléments de manière très simple, une piste intéressanre pour augmenter la rapidité des calculs.
		<hr>
		Enfin, notons que C# offre des mécanismes de base pour faire du calcul parallèle dont Marsupilami tire parti.
	</aside>
</section>
	

<section class="">
	<h5 class="">Architecture</h5>
	<ul>
		<li>.Net Core is open source (>4.6)</li>
		<li>Roslyn compiler is open source</li>
		<li>Rhino & Grasshoper</li>
		<li>DLL</li>
		<li>API</li>
		<li>Independante Mathlib</li>
		<li>OOP + EVENT</li>
		<li>Auto Refine</li>
		<li>Parallel loop / SIMD GPU computing vs reduced DOF model</li>
		<li> mixed DOF</li>
		<li>Modularity Orher types of elements</li>
		<li>Serialization / Vizualization</li>
		<li>In the browser Javascript</li>
	</ul>
	</div>
	<aside class="notes">	
	</aside>
</section>

<!-- 
=============================================================================================== 
	Test Case
=============================================================================================== 
-->

<section class="plan center">
	<strong>Test Case</strong>
	<aside class="notes">
	</aside>
</section>

<section class="">
	<h5 class="">Constrained Arch</h5>
	<ul>
		<li>Naturally straight beam with rectangular cross-section $4\times6cm$</li>
		<li>$E=25\,GPa \;,\; G=10\,GPa \;  $</li>
		<li>$L=10.0\,m\;,\;a = 2.0\,m$</li>
		<li>Discretization (number of edges) : $n=6,12,24,48,96$ </li>
	</ul>
	<hr>
	<img data-src="./img/eq/bench_drawing.svg">
	<aside class="notes">
	</aside>
</section>

<section class="black center">
	<h5 class="">Abaqus</h5>
	<img class="stretch" data-src="./img/eq/bench_abaqus_anim.gif" />
</section>

<section class="black center">
	<h5 class="">Marsupilami</h5>
	<video data-autoplay class="stretch" data-src="./img/mov/bench_marsupilami.mp4"></video>
</section>

<section class="">
	<h5 class="">Constrained Arch</h5>
	<ul>
		<li>CPU Time for Marsupilami (ST) : 80 - 160 - 320 - 740 - 1480 ms</li>
		<li>CPU Time for Abaqus (MT) : 4200 - 5400 - 6400 - 6400 - 9700 ms</li>
		<li>Relative error for apex position (M/A) : 12.6 - 3.2 - 0.8 - 0.2 - 0.0 %</li>
	</ul>
	<hr>
	<object width="50%" type="image/svg+xml" data="img/eq/bench_diagram.svg"></object>
	<aside class="notes">
	</aside>
</section>

<!-- 
=============================================================================================== 
	Other Examples
=============================================================================================== 
-->

<section class="plan center">
	<strong>Other Examples</strong>
	<aside class="notes">
		Le manuscrit ne comporte pas beaucoup d'exemples. Il faut les détailler rigoureusement.
		Icic je montre juste quelques ilages de calcules pour donner une idée plus fidèle de ce qu'il est possible de faire.
	</aside>
</section>

<section class="">
	<h5 class="">CLAMPED-PINNED</h5>
	<p>$F_x=3000\,N \;,\; f_x=1000\,N \;,\; F_y=0/1000\,N \;,\; M_3=1000\,Nm \;,\; m_3=500\,Nm$</p>
	<hr>
	<img class="imgfragment" src="./img/case/cp.gif" width="90%"/>
	<aside class="notes">
		Ajout d'un effort tranchant.
		Effet de catène qui fait remonter l'effort normal.
		Saut d'effort tranchant.
		Développe du moment de flexion.
		On retrouve les CL : clamped et pin.
		Efforts linéiques.
	</aside>
</section>

<section class="">
	<h5 class="">CANTILEVER A</h5>
	<p>$M_2=0/1000/5000/10000/20000/30000/40000\,Nm$</p>
	<hr>
	<img class="imgfragment" src="./img/case/cantilever_B.gif" width="90%"/>
	<aside class="notes">
		Flexion pure dans le plan. La poutre s'enroule sur elle même à courbure constante
	</aside>
</section>

<section class="">
	<h5 class="">CANTILEVER B</h5>
	<p>$F_z=-500\,N \;,\; M_1=100\,Nm \;,\; M_3=0/500/1000/2000/30000\,Nm$</p>
	<hr>
	<img class="imgfragment" src="./img/case/cantilever_C.gif" width="90%"/>
	<aside class="notes">
		Déversement progressif par augmentation du moment de torsion.
		Transfert de moment de flexion de l'axe 1 vers 2 dufait de la rotation de la section.
		Idem pour l'effort tranchant.
	</aside>
</section>

<section class="">
	<h5 class="">GRIDSHELL B</h5>
	<p>3x3 gridshell</p>
	<hr>
	<img class="imgfragment" src="./img/case/gs.gif" width="90%"/>
	<aside class="notes">
		Déversement progressif par augmentation du moment de torsion.
		Transfert de moment de flexion de l'axe 1 vers 2 dufait de la rotation de la section.
		Idem pour l'effort tranchant.
	</aside>
</section>

<!-- 
=============================================================================================== 
	Conclusions
=============================================================================================== 
-->

<section class="plan center">
		<strong>Conclusion</strong>
		<aside class="notes">
			Le manuscrit ne comporte pas beaucoup d'exemples. Il faut les détailler rigoureusement.
			Icic je montre juste quelques ilages de calcules pour donner une idée plus fidèle de ce qu'il est possible de faire.
		</aside>
	</section>